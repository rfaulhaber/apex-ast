// typeDeclaration
//     : classOrInterfaceModifier*
//       (classDeclaration | enumDeclaration | interfaceDeclaration | annotationTypeDeclaration)
//     | ';'
//     ;

// modifier
//     : classOrInterfaceModifier
//     | NATIVE
//     | SYNCHRONIZED
//     | TRANSIENT
//     | VOLATILE
//     ;

// classOrInterfaceModifier
//     : annotation
//     | PUBLIC
//     | PROTECTED
//     | PRIVATE
//     | STATIC
//     | ABSTRACT
//     | FINAL    // FINAL for class only -- does not apply to interfaces
//     | STRICTFP
//     ;

// variableModifier
//     : FINAL
//     | annotation
//     ;

// classDeclaration
//     : CLASS IDENTIFIER typeParameters?
//       (EXTENDS typeType)?
//       (IMPLEMENTS typeList)?
//       classBody
//     ;

// typeParameters
//     : '<' typeParameter (',' typeParameter)* '>'
//     ;

// typeParameter
//     : annotation* IDENTIFIER (EXTENDS typeBound)?
//     ;

// typeBound
//     : typeType ('&' typeType)*
//     ;

// enumDeclaration
//     : ENUM IDENTIFIER (IMPLEMENTS typeList)? '{' enumConstants? ','? enumBodyDeclarations? '}'
//     ;

// enumConstants
//     : enumConstant (',' enumConstant)*
//     ;

// enumConstant
//     : annotation* IDENTIFIER arguments? classBody?
//     ;

// enumBodyDeclarations
//     : ';' classBodyDeclaration*
//     ;

// interfaceDeclaration
//     : INTERFACE IDENTIFIER typeParameters? (EXTENDS typeList)? interfaceBody
//     ;

// classBody
//     : '{' classBodyDeclaration* '}'
//     ;

// interfaceBody
//     : '{' interfaceBodyDeclaration* '}'
//     ;

// classBodyDeclaration
//     : ';'
//     | STATIC? block
//     | modifier* memberDeclaration
//     ;

// memberDeclaration
//     : methodDeclaration
//     | genericMethodDeclaration
//     | fieldDeclaration
//     | constructorDeclaration
//     | genericConstructorDeclaration
//     | interfaceDeclaration
//     | annotationTypeDeclaration
//     | classDeclaration
//     | enumDeclaration
//     ;

// /* We use rule this even for void methods which cannot have [] after parameters.
//    This simplifies grammar and we can consider void to be a type, which
//    renders the [] matching as a context-sensitive issue or a semantic check
//    for invalid return type after parsing.
//  */
// methodDeclaration
//     : typeTypeOrVoid IDENTIFIER formalParameters ('[' ']')*
//       (THROWS qualifiedNameList)?
//       methodBody
//     ;

// methodBody
//     : block
//     | ';'
//     ;

// typeTypeOrVoid
//     : typeType
//     | VOID
//     ;

// genericMethodDeclaration
//     : typeParameters methodDeclaration
//     ;

// genericConstructorDeclaration
//     : typeParameters constructorDeclaration
//     ;

// constructorDeclaration
//     : IDENTIFIER formalParameters (THROWS qualifiedNameList)? constructorBody=block
//     ;

// fieldDeclaration
//     : typeType variableDeclarators ';'
//     ;

// interfaceBodyDeclaration
//     : modifier* interfaceMemberDeclaration
//     | ';'
//     ;

// interfaceMemberDeclaration
//     : constDeclaration
//     | interfaceMethodDeclaration
//     | genericInterfaceMethodDeclaration
//     | interfaceDeclaration
//     | annotationTypeDeclaration
//     | classDeclaration
//     | enumDeclaration
//     ;

// constDeclaration
//     : typeType constantDeclarator (',' constantDeclarator)* ';'
//     ;

// constantDeclarator
//     : IDENTIFIER ('[' ']')* '=' variableInitializer
//     ;

// // see matching of [] comment in methodDeclaratorRest
// // methodBody from Java8
// interfaceMethodDeclaration
//     : interfaceMethodModifier* (typeTypeOrVoid | typeParameters annotation* typeTypeOrVoid)
//       IDENTIFIER formalParameters ('[' ']')* (THROWS qualifiedNameList)? methodBody
//     ;

// // Java8
// interfaceMethodModifier
//     : annotation
//     | PUBLIC
//     | ABSTRACT
//     | DEFAULT
//     | STATIC
//     | STRICTFP
//     ;

// genericInterfaceMethodDeclaration
//     : typeParameters interfaceMethodDeclaration
//     ;

// variableDeclarators
//     : variableDeclarator (',' variableDeclarator)*
//     ;

// variableDeclarator
//     : variableDeclaratorId ('=' variableInitializer)?
//     ;

// variableDeclaratorId
//     : IDENTIFIER ('[' ']')*
//     ;

// variableInitializer
//     : arrayInitializer
//     | expression
//     ;

// arrayInitializer
//     : '{' (variableInitializer (',' variableInitializer)* (',')? )? '}'
//     ;

// classOrInterfaceType
//     : IDENTIFIER typeArguments? ('.' IDENTIFIER typeArguments?)*
//     ;

// typeArgument
//     : typeType
//     | '?' ((EXTENDS | SUPER) typeType)?
//     ;

// qualifiedNameList
//     : qualifiedName (',' qualifiedName)*
//     ;

// formalParameters
//     : '(' formalParameterList? ')'
//     ;

// formalParameterList
//     : formalParameter (',' formalParameter)* (',' lastFormalParameter)?
//     | lastFormalParameter
//     ;

// formalParameter
//     : variableModifier* typeType variableDeclaratorId
//     ;

// lastFormalParameter
//     : variableModifier* typeType '...' variableDeclaratorId
//     ;

// qualifiedName
//     : IDENTIFIER ('.' IDENTIFIER)*
//     ;

// literal
//     : integerLiteral
//     | floatLiteral
//     | CHAR_LITERAL
//     | STRING_LITERAL
//     | BOOL_LITERAL
//     | NULL_LITERAL
//     ;

// integerLiteral
//     : DECIMAL_LITERAL
//     | HEX_LITERAL
//     | OCT_LITERAL
//     | BINARY_LITERAL
//     ;

// floatLiteral
//     : FLOAT_LITERAL
//     | HEX_FLOAT_LITERAL
//     ;

// // ANNOTATIONS

// annotation
//     : '@' qualifiedName ('(' ( elementValuePairs | elementValue )? ')')?
//     ;

// elementValuePairs
//     : elementValuePair (',' elementValuePair)*
//     ;

// elementValuePair
//     : IDENTIFIER '=' elementValue
//     ;

// elementValue
//     : expression
//     | annotation
//     | elementValueArrayInitializer
//     ;

// elementValueArrayInitializer
//     : '{' (elementValue (',' elementValue)*)? (',')? '}'
//     ;

// annotationTypeDeclaration
//     : '@' INTERFACE IDENTIFIER annotationTypeBody
//     ;

// annotationTypeBody
//     : '{' (annotationTypeElementDeclaration)* '}'
//     ;

// annotationTypeElementDeclaration
//     : modifier* annotationTypeElementRest
//     | ';' // this is not allowed by the grammar, but apparently allowed by the actual compiler
//     ;

// annotationTypeElementRest
//     : typeType annotationMethodOrConstantRest ';'
//     | classDeclaration ';'?
//     | interfaceDeclaration ';'?
//     | enumDeclaration ';'?
//     | annotationTypeDeclaration ';'?
//     ;

// annotationMethodOrConstantRest
//     : annotationMethodRest
//     | annotationConstantRest
//     ;

// annotationMethodRest
//     : IDENTIFIER '(' ')' defaultValue?
//     ;

// annotationConstantRest
//     : variableDeclarators
//     ;

// defaultValue
//     : DEFAULT elementValue
//     ;

// // STATEMENTS / BLOCKS

// block
//     : '{' blockStatement* '}'
//     ;

// blockStatement
//     : localVariableDeclaration ';'
//     | statement
//     | localTypeDeclaration
//     ;

// localVariableDeclaration
//     : variableModifier* typeType variableDeclarators
//     ;

// localTypeDeclaration
//     : classOrInterfaceModifier*
//       (classDeclaration | interfaceDeclaration)
//     | ';'
//     ;

// statement
//     : blockLabel=block
//     | ASSERT expression (':' expression)? ';'
//     | IF parExpression statement (ELSE statement)?
//     | FOR '(' forControl ')' statement
//     | WHILE parExpression statement
//     | DO statement WHILE parExpression ';'
//     | TRY block (catchClause+ finallyBlock? | finallyBlock)
//     | TRY resourceSpecification block catchClause* finallyBlock?
//     | SWITCH parExpression '{' switchBlockStatementGroup* switchLabel* '}'
//     | SYNCHRONIZED parExpression block
//     | RETURN expression? ';'
//     | THROW expression ';'
//     | BREAK IDENTIFIER? ';'
//     | CONTINUE IDENTIFIER? ';'
//     | SEMI
//     | statementExpression=expression ';'
//     | identifierLabel=IDENTIFIER ':' statement
//     ;

// catchClause
//     : CATCH '(' variableModifier* catchType IDENTIFIER ')' block
//     ;

// catchType
//     : qualifiedName ('|' qualifiedName)*
//     ;

// finallyBlock
//     : FINALLY block
//     ;

// resourceSpecification
//     : '(' resources ';'? ')'
//     ;

// resources
//     : resource (';' resource)*
//     ;

// resource
//     : variableModifier* classOrInterfaceType variableDeclaratorId '=' expression
//     ;

// /** Matches cases then statements, both of which are mandatory.
//  *  To handle empty cases at the end, we add switchLabel* to statement.
//  */
// switchBlockStatementGroup
//     : switchLabel+ blockStatement+
//     ;

// switchLabel
//     : CASE (constantExpression=expression | enumConstantName=IDENTIFIER) ':'
//     | DEFAULT ':'
//     ;

// forControl
//     : enhancedForControl
//     | forInit? ';' expression? ';' forUpdate=expressionList?
//     ;

// forInit
//     : localVariableDeclaration
//     | expressionList
//     ;

// enhancedForControl
//     : variableModifier* typeType variableDeclaratorId ':' expression
//     ;

// // EXPRESSIONS

// parExpression
//     : '(' expression ')'
//     ;

// expressionList
//     : expression (',' expression)*
//     ;

// methodCall
//     : IDENTIFIER '(' expressionList? ')'
//     | THIS '(' expressionList? ')'
//     | SUPER '(' expressionList? ')'
//     ;

// expression
//     : primary
//     | expression bop='.'
//       ( IDENTIFIER
//       | methodCall
//       | THIS
//       | NEW nonWildcardTypeArguments? innerCreator
//       | SUPER superSuffix
//       | explicitGenericInvocation
//       )
//     | expression '[' expression ']'
//     | methodCall
//     | NEW creator
//     | '(' typeType ')' expression
//     | expression postfix=('++' | '--')
//     | prefix=('+'|'-'|'++'|'--') expression
//     | prefix=('~'|'!') expression
//     | expression bop=('*'|'/'|'%') expression
//     | expression bop=('+'|'-') expression
//     | expression ('<' '<' | '>' '>' '>' | '>' '>') expression
//     | expression bop=('<=' | '>=' | '>' | '<') expression
//     | expression bop=INSTANCEOF typeType
//     | expression bop=('==' | '!=') expression
//     | expression bop='&' expression
//     | expression bop='^' expression
//     | expression bop='|' expression
//     | expression bop='&&' expression
//     | expression bop='||' expression
//     | expression bop='?' expression ':' expression
//     | <assoc=right> expression
//       bop=('=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '>>=' | '>>>=' | '<<=' | '%=')
//       expression

// classType
//     : (classOrInterfaceType '.')? annotation* IDENTIFIER typeArguments?
//     ;

// creator
//     : nonWildcardTypeArguments createdName classCreatorRest
//     | createdName (arrayCreatorRest | classCreatorRest)
//     ;

// createdName
//     : IDENTIFIER typeArgumentsOrDiamond? ('.' IDENTIFIER typeArgumentsOrDiamond?)*
//     | primitiveType
//     ;

// innerCreator
//     : IDENTIFIER nonWildcardTypeArgumentsOrDiamond? classCreatorRest
//     ;

// arrayCreatorRest
//     : '[' (']' ('[' ']')* arrayInitializer | expression ']' ('[' expression ']')* ('[' ']')*)
//     ;

// classCreatorRest
//     : arguments classBody?
//     ;

// nonWildcardTypeArguments
//     : '<' typeList '>'
//     ;

// explicitGenericInvocationSuffix
//     : SUPER superSuffix
//     | IDENTIFIER arguments
//     ;

// arguments
//     : '(' expressionList? ')'
//     ;

// expression
//     : primary
//      this is the key to understanding method calls!
//     | expression bop='.'
//       ( IDENTIFIER
//       | methodCall
//       | THIS
//       | NEW nonWildcardTypeArguments? innerCreator
//       | SUPER superSuffix
//       | explicitGenericInvocation
//       )
//     | expression '[' expression ']'
//     | methodCall
//     | NEW creator
//     | '(' typeType ')' expression
//     | expression postfix=('++' | '--')
//     | prefix=('+'|'-'|'++'|'--') expression
//     | prefix=('~'|'!') expression
//     | expression bop=('*'|'/'|'%') expression
//     | expression bop=('+'|'-') expression
//     | expression ('<' '<' | '>' '>' '>' | '>' '>') expression
//     | expression bop=('<=' | '>=' | '>' | '<') expression
//     | expression bop=INSTANCEOF typeType
//     | expression bop=('==' | '!=') expression
//     | expression bop='&' expression
//     | expression bop='^' expression
//     | expression bop='|' expression
//     | expression bop='&&' expression
//     | expression bop='||' expression
//     | expression bop='?' expression ':' expression
//     | <assoc=right> expression
//       bop=('=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '>>=' | '>>>=' | '<<=' | '%=')
//       expression

expression = {
    primary
}

// infix_expr = { expression ~ (binary_operator ~ expression)+ }

// prefix_expr = { (INC_OP | DEC_OP) ~ expression }
// postfix_expr = { expression ~ (INC_OP | DEC_OP) }

// Primary: 
//     Literal
//     ParExpression
//     this [Arguments]
//     super SuperSuffix
//     new Creator
//     NonWildcardTypeArguments (ExplicitGenericInvocationSuffix | this Arguments)
//     Identifier { . Identifier } [IdentifierSuffix]
//     BasicType {[]} . class
//     void . class


// this name comes courtesy to us from java
primary = {
    THIS ~ arguments?
    | SUPER ~ super_suffix
    | new_instance_expr
    | method_call
    | literal
    | identifier
}

super_suffix = {
    arguments
    | "." ~ identifier ~ arguments
}

method_call = { 
    identifier ~ arguments
    | THIS ~ arguments?
    | SUPER ~ arguments?
}

new_instance_expr = { NEW ~ basic_type ~ arguments }

arguments = { "(" ~ argument_list? ~ ")" } 
argument_list = _{ expression ~ ("," ~ expression)* }

basic_type = { class_or_interface_type | primitive_type }

class_or_interface_type = { identifier ~ type_arguments? ~ ("." ~ identifier)? }

// apex only has typed types of up to two types.
// Map<String, String> => two types
// List<String> => one type
type_arguments = { two_type_arguments | one_type_argument }

two_type_arguments = { "<" ~ typed_type ~ "," ~ typed_type ~ ">" }
one_type_argument = { "<" ~ typed_type ~ ">" }

// blame the java grammar for this name, not me!
typed_type = { (class_or_interface_type | primitive_type) ~ ("[" ~ "]")? }

qualified_name = { identifier ~ ("." ~ identifier)* }

// "primitive"
primitive_type = {
    BLOB
    | BOOLEAN
    | DATE
    | DATETIME
    | DECIMAL
    | DOUBLE
    | ID
    | INTEGER
    | LONG
    | OBJECT
    | STRING
    | TIME
}

literal = {
    float_literal
    | long_literal
    | integer_literal
    | string_literal
    | bool_literal
    | null_literal
}

// NOTE: based on manual testing, apex does not support hex, octal, or binary
// literals. if they are needed, they could be implemented like this, thanks
// to the huia programming language:
// integer_hexadecimal         = @{ (ASCII_DIGIT | 'a'..'f' | 'A'..'F') ~ (ASCII_DIGIT | 'a'..'f' | 'A'..'F' | "_")* }
// integer_hexadecimal_sigil   = _{ "0x" ~ integer_hexadecimal }
// integer_octal               = @{ ('0'..'7') ~ ('0'..'7' | "_" )* }
// integer_octal_sigil         = _{ "0o" ~ integer_octal }
// integer_binary              = @{ ('0'..'1') ~ ('0'..'1' | "_")* }
// integer_binary_sigil        = _{ "0b" ~ integer_binary }

long_literal = @{ integer_literal ~ ^"L" }

integer_literal = @{ "-"? ~ ASCII_NONZERO_DIGIT ~ (ASCII_DIGIT | "_")* }

float_literal = @{ ASCII_DIGIT* ~ "." ~ ASCII_DIGIT* | "." ~ ASCII_DIGIT* }

// TODO: hex float literal?
// from antlr: HEX_FLOAT_LITERAL:  '0' [xX] (HexDigits '.'? | HexDigits? '.' HexDigits) [pP] [+-]? Digits [fFdD]?;

bool_literal = { TRUE | FALSE }

string_literal = @{ "'" ~ string_inner ~ "'" }
string_inner = @{ char* }
char = { !("\'" | "\\") ~ ANY | escape_sequence }

null_literal = { ^"null" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// NOTE: strangely, apex doesn't support exponential literals
// exponent_part = {
//     ^"e" ~ ("+" | "-")? ~ ASCII_DIGIT
// }

escape_sequence = {
    "\\" ~ ("\\" |"b" | "f" | "n" | "t" | "r" | "'")
    | "\\" ~ ('0' .. '3')? ~ ('0' .. '7')? ~ ('0' .. '7')
    | "\\" ~ "u" ~ ASCII_HEX_DIGIT{4}
}

BLOB = { ^"Blob" }
BOOLEAN = { ^"Boolean" }
DATE = { ^"Date" }
DATETIME = { ^"Datetime" }
DECIMAL = { ^"Decimal" }
DOUBLE = { ^"Double" }
ID = { ^"ID" }
INTEGER = { ^"Integer" }
LONG = { ^"Long" }
OBJECT = { ^"Object" }
STRING = { ^"String" } 
TIME = { ^"Time" }

assignment_operator = _{
    ASSIGNMENT
    | ADD_ASSIGN
    | SUB_ASSIGN
    | MUL_ASSIGN
    | DIV_ASSIGN
    | AND_ASSIGN
    | OR_ASSIGN
    | XOR_ASSIGN
    | LEFT_SHIFT_ASSIGN
    | RIGHT_SHIFT_ASSIGN
}

ASSIGNMENT = { "=" }

binary_operator = _{
    LOGIC_AND
    | LOGIC_OR
    | GE
    | LE
    | EQ
    | NOT_EQ
    | BIT_SHIFT_LEFT
    | BIT_SHIFT_RIGHT
    | GT
    | LT
    | ADD
    | SUB
    | MUL
    | DIV
    | BIT_AND
    | BIT_OR
    | BIT_XOR
}

unary_operator = {
    LOGIC_NOT
    | BIT_NOT
    | ADD
    | SUB
}

INC_OP = { "++" }
DEC_OP = { "--" }

LOGIC_AND = { "&&" }
LOGIC_OR = { "||" }
LOGIC_NOT = { "!" }

GE = { ">=" }
GT = { ">" }
LE = { "<=" }
LT = { "<" }
EQ = { "==" }
NOT_EQ = { "!=" }

ADD = { "+" }
SUB = { "-" }
MUL = { "*" }
DIV = { "/" }

ADD_ASSIGN = { "+=" }
SUB_ASSIGN = { "-=" }
MUL_ASSIGN = { "*=" }
DIV_ASSIGN = { "/=" }
AND_ASSIGN = { "&=" }
OR_ASSIGN = { "|=" }
XOR_ASSIGN = { "^=" }
LEFT_SHIFT_ASSIGN = { "<<=" }
RIGHT_SHIFT_ASSIGN = { ">>=" }
URSHIFT_ASSIGN = { ">>>=" }

BIT_AND = { "&" }
BIT_OR = { "|" }
BIT_XOR = { "^" }
BIT_NOT = { "~" }
BIT_SHIFT_LEFT = { "<<" }
BIT_SHIFT_RIGHT = { ">>" }

// apex keywords convenience rule
apex_keyword = _{
    ABSTRACT
    | BOOLEAN
    | BREAK
    | CATCH
    | CLASS
    | CONTINUE
    | DEFAULT
    | DO
    | ELSE
    | ENUM
    | EXTENDS
    | FALSE
    | FINALLY
    | FINAL
    | FOR
    | GET
    | GLOBAL
    | IF
    | IMPLEMENTS
    | INHERITED_SHARING
    | INSTANCEOF
    | INTERFACE
    | NEW
    | OVERRIDE
    | PRIVATE
    | PROTECTED
    | PUBLIC
    | RETURN
    | SET
    | STATIC
    | SUPER
    | THIS
    | THROW
    | TRANSIENT
    | TRUE
    | TRY
    | VIRTUAL
    | VOID
    | WHILE
    | WITHOUT_SHARING
    | WITH_SHARING
}

// apex keywords
ABSTRACT = { ^"abstract" }
AFTER = { ^"after" }
BEFORE = { ^"before" }
BREAK = { ^"break" }
CATCH = { ^"catch" }
CLASS = { ^"class" }
CONTINUE = { ^"continue" }
DEFAULT = { ^"default" }
DELETE = { ^"delete" }
DO = { ^"do" }
ELSE = { ^"else" }
ENUM = { ^"enum" }
EXTENDS = { ^"extends" }
FALSE = { ^"false" }
FINAL = { ^"final" }
FINALLY = { ^"finally" }
FOR = { ^"for" }
GET = { ^"get" }
GLOBAL = { ^"global" }
IF = { ^"if" }
IMPLEMENTS = { ^"implements" }
INHERITED_SHARING = { ^"inherited sharing" }
INSERT = { ^"insert" }
INSTANCEOF = { ^"instanceof" }
INTERFACE = { ^"interface" }
NEW = { ^"new" }
NULL = { ^"null" }
ON = { ^"on" }
OVERRIDE = { ^"override" }
PRIVATE = { ^"private" }
PROTECTED = { ^"protected" }
PUBLIC = { ^"public" }
RETURN = { ^"return" }
SET = { ^"set" }  
STATIC = { ^"static" }
SUPER = { ^"super" }
SWITCH = { ^"switch" }
THIS = { ^"this" }
THROW = { ^"throw" }
TRANSIENT = { ^"transient" }
TRIGGER = { ^"trigger" }
TRUE = { ^"true" }
TRY = { ^"try" }
UNDELETE = { ^"undelete" }
UPDATE = { ^"update" }
UPSERT = { ^"upsert" }
VIRTUAL = { ^"virtual" }
VOID = { ^"void" }
WHILE = { ^"while" }
WITHOUT_SHARING = { ^"without sharing" }
WITH_SHARING = { ^"with sharing" }

WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }
COMMENT = _{ comment_block | comment_line }
comment_block = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line = @{ "//" ~ (!NEWLINE ~ ANY)* }