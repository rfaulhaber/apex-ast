// typeDeclaration
//     : classOrInterfaceModifier*
//       (classDeclaration | enumDeclaration | interfaceDeclaration | annotationTypeDeclaration)
//     | ';'
//     ;

// modifier
//     : classOrInterfaceModifier
//     | NATIVE
//     | SYNCHRONIZED
//     | TRANSIENT
//     | VOLATILE
//     ;

// classOrInterfaceModifier
//     : annotation
//     | PUBLIC
//     | PROTECTED
//     | PRIVATE
//     | STATIC
//     | ABSTRACT
//     | FINAL    // FINAL for class only -- does not apply to interfaces
//     | STRICTFP
//     ;

// variableModifier
//     : FINAL
//     | annotation
//     ;

// classDeclaration
//     : CLASS IDENTIFIER typeParameters?
//       (EXTENDS typeType)?
//       (IMPLEMENTS typeList)?
//       classBody
//     ;

// typeParameters
//     : '<' typeParameter (',' typeParameter)* '>'
//     ;

// typeParameter
//     : annotation* IDENTIFIER (EXTENDS typeBound)?
//     ;

// typeBound
//     : typeType ('&' typeType)*
//     ;

// enumDeclaration
//     : ENUM IDENTIFIER (IMPLEMENTS typeList)? '{' enumConstants? ','? enumBodyDeclarations? '}'
//     ;

// enumConstants
//     : enumConstant (',' enumConstant)*
//     ;

// enumConstant
//     : annotation* IDENTIFIER arguments? classBody?
//     ;

// enumBodyDeclarations
//     : ';' classBodyDeclaration*
//     ;

// interfaceDeclaration
//     : INTERFACE IDENTIFIER typeParameters? (EXTENDS typeList)? interfaceBody
//     ;

// classBody
//     : '{' classBodyDeclaration* '}'
//     ;

// interfaceBody
//     : '{' interfaceBodyDeclaration* '}'
//     ;

// classBodyDeclaration
//     : ';'
//     | STATIC? block
//     | modifier* memberDeclaration
//     ;

// memberDeclaration
//     : methodDeclaration
//     | genericMethodDeclaration
//     | fieldDeclaration
//     | constructorDeclaration
//     | genericConstructorDeclaration
//     | interfaceDeclaration
//     | annotationTypeDeclaration
//     | classDeclaration
//     | enumDeclaration
//     ;

// /* We use rule this even for void methods which cannot have [] after parameters.
//    This simplifies grammar and we can consider void to be a type, which
//    renders the [] matching as a context-sensitive issue or a semantic check
//    for invalid return type after parsing.
//  */
// methodDeclaration
//     : typeTypeOrVoid IDENTIFIER formalParameters ('[' ']')*
//       (THROWS qualifiedNameList)?
//       methodBody
//     ;

// methodBody
//     : block
//     | ';'
//     ;

// typeTypeOrVoid
//     : typeType
//     | VOID
//     ;

// genericMethodDeclaration
//     : typeParameters methodDeclaration
//     ;

// genericConstructorDeclaration
//     : typeParameters constructorDeclaration
//     ;

// constructorDeclaration
//     : IDENTIFIER formalParameters (THROWS qualifiedNameList)? constructorBody=block
//     ;

// fieldDeclaration
//     : typeType variableDeclarators ';'
//     ;

// interfaceBodyDeclaration
//     : modifier* interfaceMemberDeclaration
//     | ';'
//     ;

// interfaceMemberDeclaration
//     : constDeclaration
//     | interfaceMethodDeclaration
//     | genericInterfaceMethodDeclaration
//     | interfaceDeclaration
//     | annotationTypeDeclaration
//     | classDeclaration
//     | enumDeclaration
//     ;

// constDeclaration
//     : typeType constantDeclarator (',' constantDeclarator)* ';'
//     ;

// constantDeclarator
//     : IDENTIFIER ('[' ']')* '=' variableInitializer
//     ;

// // see matching of [] comment in methodDeclaratorRest
// // methodBody from Java8
// interfaceMethodDeclaration
//     : interfaceMethodModifier* (typeTypeOrVoid | typeParameters annotation* typeTypeOrVoid)
//       IDENTIFIER formalParameters ('[' ']')* (THROWS qualifiedNameList)? methodBody
//     ;

// // Java8
// interfaceMethodModifier
//     : annotation
//     | PUBLIC
//     | ABSTRACT
//     | DEFAULT
//     | STATIC
//     | STRICTFP
//     ;

// genericInterfaceMethodDeclaration
//     : typeParameters interfaceMethodDeclaration
//     ;

// variableDeclarators
//     : variableDeclarator (',' variableDeclarator)*
//     ;

// variableDeclarator
//     : variableDeclaratorId ('=' variableInitializer)?
//     ;

// variableDeclaratorId
//     : IDENTIFIER ('[' ']')*
//     ;

// variableInitializer
//     : arrayInitializer
//     | expression
//     ;

// arrayInitializer
//     : '{' (variableInitializer (',' variableInitializer)* (',')? )? '}'
//     ;

// classOrInterfaceType
//     : IDENTIFIER typeArguments? ('.' IDENTIFIER typeArguments?)*
//     ;

// typeArgument
//     : typeType
//     | '?' ((EXTENDS | SUPER) typeType)?
//     ;

// formalParameter
//     : variableModifier* typeType variableDeclaratorId
//     ;

// lastFormalParameter
//     : variableModifier* typeType '...' variableDeclaratorId
//     ;

// qualifiedName
//     : IDENTIFIER ('.' IDENTIFIER)*
//     ;

class_declaration = { access_modifier? ~ (ABSTRACT | VIRTUAL | sharing_modifier)? ~ CLASS ~ identifier ~ (EXTENDS ~ basic_type)? ~ (IMPLEMENTS ~ type_list)? ~ class_body }
class_body = { "{" ~ (inner_class_declaration | inner_interface_declaration | class_member_variable_declaration | static_block | class_constructor_definition | class_method_declaration)* ~ "}" }
inner_class_declaration = { access_modifier? ~ (ABSTRACT | VIRTUAL | sharing_modifier)? ~ CLASS ~ identifier ~ (EXTENDS ~ basic_type)? ~ (IMPLEMENTS ~ type_list)? ~ inner_class_body }
inner_class_body = { "{" ~ (class_member_variable_declaration | class_constructor_definition | static_block | class_method_declaration)* ~ "}" }
inner_interface_declaration = { access_modifier? ~ VIRTUAL? ~ interface_declaration }
// // basically methods without return type 
class_constructor_definition = { annotation? ~ access_modifier? ~ identifier ~ parameter_list ~ block }
class_member_accessors = { "{" ~ get_accessor? ~ set_accessor? ~ "}" }
get_accessor = { access_modifier? ~ GET ~ (block | ";") }
set_accessor = { access_modifier? ~ SET ~ (block | ";") }

sharing_modifier = {
    WITHOUT_SHARING
    | WITH_SHARING
    | INHERITED_SHARING
}

// interface declaration
interface_declaration = { access_modifier? ~ INTERFACE ~ identifier ~ (EXTENDS ~ type_list)? ~ interface_body }
interface_body = { "{" ~ interface_method_declaration* ~ "}" }
interface_method_declaration = { basic_type ~ identifier ~ parameter_list ~ ";" }

type_list = { basic_type ~ ("," ~ basic_type)* }

// annotations

annotation = { "@" ~ identifier ~ annotation_pair_list? }
annotation_pair_list = _{ "(" ~ annotation_pair+ ~ ")" }

// we're making it easy on ourselves! apex annotations aren't complex!
annotation_pair = { identifier ~ "=" ~ literal }


// non-method class members

class_member_variable_declaration = { 
    annotation? 
    ~ access_modifier? 
    ~ (STATIC | TRANSIENT)? 
    ~ FINAL? 
    ~ basic_type 
    ~ identifier 
    ~ declaration_rhs? 
}

// static blocks

static_block = { STATIC ~ block }

// methods

access_modifier = { GLOBAL | PUBLIC | PROTECTED | PRIVATE }

parameter_list = { "(" ~ (parameter ~ ("," ~ parameter)*)? ~ ")" }
parameter = { basic_type ~ identifier }
class_method_declaration = { annotation? ~ access_modifier? ~ (OVERRIDE | STATIC | VIRTUAL | ABSTRACT)? ~ basic_type ~ identifier ~ parameter_list ~ block }

block = { "{" ~ statement* ~ "}" }
inline_block = { statement }

// statements

statement = {
    for_stmt
    | do_while_stmt
    | while_stmt
    | if_stmt
    | switch_stmt
    | try_catch_stmt
    | return_stmt
    | throw_stmt
    | break_stmt
    | continue_stmt
    | local_variable_declaration
    | stmt_expr ~ ";"
}

// if statements
if_stmt = { IF ~ if_condition ~ (inline_block | block) ~ else_if_block* ~ else_block? }
if_condition = { "(" ~ expression ~ ")" }
else_if_block = { ELSE ~ IF ~ if_condition ~ (inline_block | block) }
else_block = { ELSE ~ (inline_block | block) }

// switch statements
switch_stmt = { SWITCH ~ ON ~ expression ~ "{" ~ when_case* ~ when_else? ~ "}" }
when_case = { WHEN ~ when_condition ~ block }
when_condition = { when_type | when_value_list }
when_type = { basic_type ~ identifier }
when_value_list = { literal ~ ("," ~ literal)* | identifier ~ ("," ~ identifier)* }
when_else = { WHEN ~ ELSE ~ block }

// for statements
// these names come to us courtesy of java as well
for_stmt = { for_basic | for_enhanced }

// "basic" for loops. 
// infinite for loops are allowed in apex.
// by means of experimentation, apex doesn't allow for multiple statement 
// expressions in the update term, leading to this unusual rule.
for_basic = { FOR ~ "(" ~ for_init? ~ ";" ~ expression? ~ ";" ~ stmt_expr? ~ ")" ~ (inline_block | block) }
for_init = { stmt_expr ~ ("," ~ stmt_expr)* }

// "enhanced" for loop
for_enhanced = { FOR ~ "(" ~ basic_type ~ identifier ~ ":" ~ expression ~ ")" ~ (inline_block | block) }

// while statements
while_stmt = { WHILE ~ "(" ~ expression ~ ")" ~ (inline_block | block) }

// do while statements
do_while_stmt = { DO ~ (inline_block | block) ~ WHILE ~ "(" ~ expression ~ ")" ~ ";" }

// try / catch blocks
try_catch_stmt = { TRY ~ block ~ catch_clause+ ~ (FINALLY ~ block)? }
catch_clause = { CATCH ~ "(" ~ basic_type ~ identifier ~ ")" ~ block }

// return statements
return_stmt = { RETURN ~ expression ~ ";" }
// throw statements
throw_stmt = { THROW ~ expression ~ ";"  }

// break statements
break_stmt = { BREAK ~ ";" }

// continue statements
continue_stmt = { CONTINUE ~ ";"  }

local_variable_declaration = { FINAL? ~ basic_type ~ identifier ~ declaration_rhs? ~ ";" }
declaration_rhs = _{ "=" ~ expression }

// statement expressions. these are expressions that can stand alone as
// statements themselves. for example, "i++" is an expression until you add a
// semicolon, making "i++;" a statement.
stmt_expr = { 
    property_access
    | assignment_expr 
    | prefix_expr 
    | postfix_expr 
    | method_call 
    | new_instance_expr
}

// expressions 

expression = { infix_expr | assignment_expr | ternary_expr | expr_inner }

// these are supposed to be "terminal" expressions, to avoid left-recursion 
expr_inner = {
    braced_expr
    | property_access
    | new_instance_expr
    | method_call
    | unary_expr
    | prefix_expr
    | postfix_expr
    | instanceof_expr
    | cast_expression
    | list_access
    | primary
}


braced_expr = { !cast_operator ~ "(" ~ expression ~ ")" }
ternary_expr = { expr_inner ~ "?" ~ expr_inner ~ ":" ~ expr_inner }
infix_expr = { expr_inner ~ (binary_operator ~ expr_inner)+ }
assignment_expr = { expr_inner ~ assignment_operator ~ expr_inner }
unary_expr = { unary_operator  ~ expression }
prefix_expr = { (INC_OP | DEC_OP) ~ affixable }
postfix_expr = { affixable ~ (INC_OP | DEC_OP) }
affixable = { property_access | list_access | identifier }

// technically, something like "1 instanceof Integer" is apparently syntactically
// correct but Salesforce throws a compile-time error rather than a syntax error
instanceof_expr = { identifier ~ INSTANCEOF ~ basic_type }

// TODO make method calls distinct from property access
property_access = { (list_access | access_partial) ~ "." ~ expression }
list_access = { access_partial ~ "[" ~ expression ~ "]" }

cast_expression = { cast_operator ~ expression }
cast_operator = _{ "(" ~ basic_type ~ ")" }

access_partial = {
    new_instance_expr
    | SUPER ~ super_suffix
    | method_call
    | THIS
    | identifier
}

accessible = {
    literal
    | identifier
}

// Primary: 
//     Literal
//     ParExpression
//     this [Arguments]
//     super SuperSuffix
//     new Creator
//     NonWildcardTypeArguments (ExplicitGenericInvocationSuffix | this Arguments)
//     Identifier { . Identifier } [IdentifierSuffix]
//     BasicType {[]} . class
//     void . class


// this name comes to us courtesy of java
primary = {
    THIS ~ arguments?
    | SUPER ~ super_suffix
    | type_expr
    | literal
    | identifier
}

super_suffix = { arguments | "." ~ identifier ~ arguments }

method_call = { 
    identifier ~ arguments
    | THIS ~ arguments?
    | SUPER ~ arguments?
}

new_instance_expr = {NEW ~ (map_literal_init | array_literal_init | new_class)}

map_literal_init = { ^"MAP" ~ two_type_arguments ~ (map_literal_values | arguments) }
map_literal_values = { "{" ~ mapping_pair ~ ("," ~ mapping_pair)* ~ "}" }
mapping_pair = { expression ~ "=>" ~ expression }

array_literal_init = { collection_type ~ one_type_argument ~ (new_array_literal | arguments) }
collection_type = { ^"LIST" | ^"SET" }
new_array_literal = { "{" ~ (expression ~ ("," ~ expression)*)? ~ "}" }

new_class = { basic_type ~ arguments }

arguments = { "(" ~ argument_list? ~ ")" } 
argument_list = _{ expression ~ ("," ~ expression)* }

type_expr = { basic_type ~ "." ~ CLASS }

basic_type = { class_or_interface_type | primitive_type }

class_or_interface_type = { identifier ~ type_arguments? ~ ("." ~ identifier)? }

// apex only has typed types of up to two types.
// Map<String, String> => two types
// List<String> => one type
type_arguments = { two_type_arguments | one_type_argument }

two_type_arguments = { "<" ~ typed_type ~ "," ~ typed_type ~ ">" }
one_type_argument = { "<" ~ typed_type ~ ">" }

// blame the java grammar for this name, not me!
typed_type = { (class_or_interface_type | primitive_type) ~ ("[" ~ "]")? }

qualified_name = { identifier ~ ("." ~ identifier)* }

// "primitive"
primitive_type = {
    BLOB
    | BOOLEAN
    | DATE
    | DATETIME
    | DECIMAL
    | DOUBLE
    | ID
    | INTEGER
    | LONG
    | OBJECT
    | STRING
    | TIME
}

literal = {
    float_literal
    | long_literal
    | integer_literal
    | string_literal
    | bool_literal
    | null_literal
}

// NOTE: based on manual testing, apex does not support hex, octal, or binary
// literals. if they are needed, they could be implemented like this, thanks
// to the huia programming language:
// integer_hexadecimal         = @{ (ASCII_DIGIT | 'a'..'f' | 'A'..'F') ~ (ASCII_DIGIT | 'a'..'f' | 'A'..'F' | "_")* }
// integer_hexadecimal_sigil   = _{ "0x" ~ integer_hexadecimal }
// integer_octal               = @{ ('0'..'7') ~ ('0'..'7' | "_" )* }
// integer_octal_sigil         = _{ "0o" ~ integer_octal }
// integer_binary              = @{ ('0'..'1') ~ ('0'..'1' | "_")* }
// integer_binary_sigil        = _{ "0b" ~ integer_binary }

long_literal = @{ integer_literal ~ ^"L" }
integer_literal = @{ "0" | "-"? ~ ASCII_NONZERO_DIGIT ~ (ASCII_DIGIT | "_")* }
float_literal = @{ ASCII_DIGIT* ~ "." ~ ASCII_DIGIT* | "." ~ ASCII_DIGIT* }

// TODO: hex float literal?
// from antlr: HEX_FLOAT_LITERAL:  '0' [xX] (HexDigits '.'? | HexDigits? '.' HexDigits) [pP] [+-]? Digits [fFdD]?;

bool_literal = { TRUE | FALSE }

string_literal = @{ "'" ~ string_inner ~ "'" }
string_inner = @{ char* }
char = { !("\'" | "\\") ~ ANY | escape_sequence }

null_literal = { ^"null" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// NOTE: strangely, apex doesn't support exponential literals
// exponent_part = {
//     ^"e" ~ ("+" | "-")? ~ ASCII_DIGIT
// }

escape_sequence = {
    "\\" ~ ("\\" |"b" | "f" | "n" | "t" | "r" | "'")
    | "\\" ~ ('0' .. '3')? ~ ('0' .. '7')? ~ ('0' .. '7')
    | "\\" ~ "u" ~ ASCII_HEX_DIGIT{4}
}

BLOB = { ^"Blob" }
BOOLEAN = { ^"Boolean" }
DATE = { ^"Date" }
DATETIME = { ^"Datetime" }
DECIMAL = { ^"Decimal" }
DOUBLE = { ^"Double" }
ID = { ^"ID" }
INTEGER = { ^"Integer" }
LONG = { ^"Long" }
OBJECT = { ^"Object" }
STRING = { ^"String" } 
TIME = { ^"Time" }

assignment_operator = _{
    ASSIGNMENT
    | ADD_ASSIGN
    | SUB_ASSIGN
    | MUL_ASSIGN
    | DIV_ASSIGN
    | AND_ASSIGN
    | OR_ASSIGN
    | XOR_ASSIGN
    | LEFT_SHIFT_ASSIGN
    | RIGHT_SHIFT_ASSIGN
}

ASSIGNMENT = { "=" }

binary_operator = _{
    LOGIC_AND
    | LOGIC_OR
    | GE
    | LE
    | EQ
    | NOT_EQ
    | BIT_SHIFT_LEFT
    | BIT_SHIFT_RIGHT
    | GT
    | LT
    | ADD
    | SUB
    | MUL
    | DIV
    | BIT_AND
    | BIT_OR
    | BIT_XOR
}

unary_operator = {
    LOGIC_NOT
    | BIT_NOT
    | ADD
    | SUB
}

INC_OP = { "++" }
DEC_OP = { "--" }

LOGIC_AND = { "&&" }
LOGIC_OR = { "||" }
LOGIC_NOT = { "!" }

GE = { ">=" }
GT = { ">" }
LE = { "<=" }
LT = { "<" }
EQ = { "==" }
NOT_EQ = { "!=" }

ADD = { "+" }
SUB = { "-" }
MUL = { "*" }
DIV = { "/" }

ADD_ASSIGN = { "+=" }
SUB_ASSIGN = { "-=" }
MUL_ASSIGN = { "*=" }
DIV_ASSIGN = { "/=" }
AND_ASSIGN = { "&=" }
OR_ASSIGN = { "|=" }
XOR_ASSIGN = { "^=" }
LEFT_SHIFT_ASSIGN = { "<<=" }
RIGHT_SHIFT_ASSIGN = { ">>=" }
URSHIFT_ASSIGN = { ">>>=" }

BIT_AND = { "&" }
BIT_OR = { "|" }
BIT_XOR = { "^" }
BIT_NOT = { "~" }
BIT_SHIFT_LEFT = { "<<" }
BIT_SHIFT_RIGHT = { ">>" }

// apex keywords convenience rule
apex_keyword = _{
    ABSTRACT
    | BOOLEAN
    | BREAK
    | CATCH
    | CLASS
    | CONTINUE
    | DEFAULT
    | DO
    | ELSE
    | ENUM
    | EXTENDS
    | FALSE
    | FINALLY
    | FINAL
    | FOR
    | GET
    | GLOBAL
    | IF
    | IMPLEMENTS
    | INHERITED_SHARING
    | INSTANCEOF
    | INTERFACE
    | NEW
    | OVERRIDE
    | PRIVATE
    | PROTECTED
    | PUBLIC
    | RETURN
    | SET
    | STATIC
    | SUPER
    | THIS
    | THROW
    | TRANSIENT
    | TRUE
    | TRY
    | VIRTUAL
    | VOID
    | WHILE
    | WITHOUT_SHARING
    | WITH_SHARING
}

// apex keywords
ABSTRACT = { ^"abstract" }
AFTER = { ^"after" }
BEFORE = { ^"before" }
BREAK = { ^"break" }
CATCH = { ^"catch" }
CLASS = { ^"class" }
CONTINUE = { ^"continue" }
DEFAULT = { ^"default" }
DELETE = { ^"delete" }
DO = { ^"do" }
ELSE = { ^"else" }
ENUM = { ^"enum" }
EXTENDS = { ^"extends" }
FALSE = { ^"false" }
FINAL = { ^"final" }
FINALLY = { ^"finally" }
FOR = { ^"for" }
GET = { ^"get" }
GLOBAL = { ^"global" }
IF = { ^"if" }
IMPLEMENTS = { ^"implements" }
INHERITED_SHARING = { ^"inherited sharing" }
INSERT = { ^"insert" }
INSTANCEOF = { ^"instanceof" }
INTERFACE = { ^"interface" }
NEW = { ^"new" }
NULL = { ^"null" }
ON = { ^"on" }
OVERRIDE = { ^"override" }
PRIVATE = { ^"private" }
PROTECTED = { ^"protected" }
PUBLIC = { ^"public" }
RETURN = { ^"return" }
SET = { ^"set" }  
STATIC = { ^"static" }
SUPER = { ^"super" }
SWITCH = { ^"switch" }
THIS = { ^"this" }
THROW = { ^"throw" }
TRANSIENT = { ^"transient" }
TRIGGER = { ^"trigger" }
TRUE = { ^"true" }
TRY = { ^"try" }
UNDELETE = { ^"undelete" }
UPDATE = { ^"update" }
UPSERT = { ^"upsert" }
VIRTUAL = { ^"virtual" }
VOID = { ^"void" }
WHEN = {^"when"}
WHILE = { ^"while" }
WITHOUT_SHARING = { ^"without sharing" }
WITH_SHARING = { ^"with sharing" }

WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }
COMMENT = _{ comment_block | comment_line }
comment_block = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
comment_line = @{ "//" ~ (!NEWLINE ~ ANY)* }